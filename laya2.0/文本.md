## 1、FontClip字体剪辑组件
* 美术出图时也可以将文本多行排行，但是每个文本之间必须要等高等宽等距进行排列
* 当前的FontClip组件是面向单行的整句文本，是不支持空格的
## 2、BitmapFont位图字体类
* Bitmap Font Generator 只有windows版，对于没有windows系统的，复杂度不高的需求，尽可能通过FontClip实现。
## 3  HTML文本组件
* HTML文本是用于图文混排的文本组件，组件名为HTMLDivElement。该组件通常用于聊天室等动态文本场景需求，所以引擎也是采单字符提交图集的模式，与Graphics的文本绘制有些类似，但又不太一样，因为绘制采用的是系统字，并支持常见的HTML标签。
## 五、关于文本的性能优化
* 这两个组件，如果都是比较简单的单行文本，并且除了文本内容发生变化外，不对文本的属性（例如大小、颜色、粗细、斜体、对齐等等）作出任何改变的话。那我们可以使用 **changeText()** 来替换文本，这个方法会跳过排版直接修改该文本绘制的最后一条指令，从而优化了渲染效率。
* 而当文本内容需要改变时，哪怕只改变一个字符，如果FillText可以满足需求的话，那尽可能优先使用FillText文本组件。FillText不能满足时，其次考虑位图文本组件是否可以满足，最后再考虑静态文本组件。
* 在运行时，设置了描边的文本比没有描边的文本多调用一次绘图指令。此时，文本对CPU的使用量和文本的数量成正比。因此，尽量使用替代方案来完成同样的需求。例如，字符量较少的时候，可以使用位图文本。
* 在2D的UI布局时，如果开发者将文本与其它UI节点混合排列，那么必然会打断图集的合并渲染，增加DrawCall数量，产生不必要的性能开销
>* LayaAir IDE编辑布局时，将所有文本组件在节点中顺序排列，不要与其它UI组件穿插
>* LayaAir IDE中的组件中有一个drawCallOptimize属性，我们为所有文本的父级节点drawCallOptimize属性设置true值。当这样设置之后，引擎会自动启用文本合并优化，将所有的文本提取到最上层，而开发者无需再刻意调整图集资源和文本的排序，即可实现drawCall自动优化的目标，而且优化的更加干脆彻底。